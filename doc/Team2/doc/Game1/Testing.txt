Player:

1). Implementing player directional movement, as well as speed. 

Bugs: no bugs what-so-ever as this is conceptually very easy to implement.

2). Implementing player attack inputs, as well as attacking mechanics with preset weapon configurations.

Bugs/Notes: this took a bit of engineering upfront but it definitely paid off in the end with how easy the system is to use. Lew is able to apply certain powerup mechanics with a couple lines of code switching the Player’s primary weapon from PlayerWeapons.Standard to PlayerWeapons.IncreasedFireRate for example. Ran into a few semantic errors here and there but never ran into any bugs due to my extensive testing. This testing was mostly conducted using breakpoints to conduct unit tests on the various scripts in a variety of scenarios.

3). Implementing player ship collisions and the actions thereof for each particular type of collider. 

Bugs/Notes: players cannot kill each other if they collide, but objects colliding with them can’t, unless they are of course power ups, or other players bullets, but not enemy bullets. As you can see, there is a lot of logic to be had when it comes to processing the myriad of different events to be performed depending completely on the tag of the collider. 

	Bug #1 - I learned a lot pulling my hair out on why collisions with the player just weren’t happening, why the character would randomly die etc.. All collision systems must have shared between both parties a collider, but only one requires a rigidbody. 

	Bug #2 - Player would die almost instantly when spawning into the map. Little did I realize the background was tagged ‘Background’ and because I had yet to include this in OnTriggerEnter(), the background would kill the player.

	Bug #3 -There was at least one point when the player could kill themselves with their own bullet exiting their own gun barrel. The fix was making sure that bullets impacting entities would only do damage if that bullet’s Shooter’s tag did not match the one being shot. I. e., players can therefore not commit suicide, or kill fellow players from behind.

4). Keeping track of player lives, points, death, and respawns

Bugs/Notes: this was another one of those things that I have somewhat of a bad taste in my mouth about. I ended up creating a respawn function that waits 3 seconds after death, subtracts a life, and respawns them in the starting position with 3 seconds of invulnerability to prevent the player from being spawn killed. It wasn’t without a few conceptual engineering hangups on the way though.

	Bug/Problem #1 - Team 4 wanted us to store a timestamp of the player’s final score as well as the final score somewhere so there could retrieve it to insert it into the database. The problem was figuring out how to effectively do that without having tons of bugs. I stepped back, and eventually came up with a solution. When the player dies, there Points remain recorded, and the global isDead is set to true. This will allow team 4 to see when it's time to collect. Before the player’s ship in deactivated, we also record a Unix formatted timestamp at the exact moment the player died. The script is then deactivated, but the values retained in PlayerShip for 
Team 4 to retrieve as they see fit.

	Also, I ran into a couple semantic error here and there with the respawn function, but all in all, it went very well, and has passed all tests with effectively zero issues.

	Points are incremented for a player when one of there bullets hit an enemy, and retrieves it’s score through its EnemyHealth component. It then takes this score and increments the reference it has back to the player’s point tally before destroying itself.

Enemy:

1). Implementing enemy predefined behaviors, and AI.

	Bugs/Notes - I actually thought this one up in class while we were talking about something else. How our behavior system works is basically you have a cyclic loop of EnemyActions, called EnemyBehavior. 1 EnemyAction defines what an enemy should be doing over a particular time interval based on their particular personality. Once I got those couple classes implemented, I ended up creating a static class storing all the predefined EnemyBehaviour configurations corresponding to every type of enemy in this iteration. All you have to do to set an enemies behaviour is change its behavior_m attribute to XIEnemyBehaviours.AssaulterBehaviorStandard for example, and that particular gameobject will start moving and shooting like an Assaulter. Lots of thinking and the occasional road block here and there, but all in all I’m incredibly satisfied with the system.

2). Implementing enemy weapons based on class. 

Issues/Notes - Thanks to Jared’s rather tidy Enemy library, implementing weapons was not all that bad despite the sheer diversity of behaviors between different weapons. I ran into a lot conceptual roadblocks while drawing it all out, but in the end, I decided to implement the weapons mechanics in the daughter classes of Enemy, and leave the behavior to the base class. After all, all enemies can follow a behavior cycle, but take the Striker, and the Assaulter for example. The assaulter simply fires normal bullets forward towards the player while oscillating back and forth in the play area. A striker on the other hand has to fire a laser, DIRECTLY at a player that it must choose. This is what pushed me into leaving weapons to the derived classes.In the end, it worked out great. All weapons have been customly implemented inside the daughter classes while the actual fire commands are issued by the base class, as the Shoot() function in the base class is virtual.

Powerups:

Adding new power-ups: play tests were run to ensure that they spawned from the obstacle randomly, could be picked up by the player, awarded the appropriate buffs and modified game objects correctly. Debug logs were used to ensure variables were being correctly modified when a powerup was collected. 

-Bugs found: none, correct functionality.

Death of the player: play testing was used as well as the debug log to ensure that all power-ups that the player collected on the previously life lost. 

-Bugs found: not all powerup functionality was being removed from the player, but it was easily correctly and now functions properly.

Laser powerup: Both play tests and debug logs were used to ensure that both the physical laser would change size on charge, but also the values that were used to change the size were correct. 

	-Bugs found: 	1) Laser instantly destroys the player and itself upon firing
		        2) Laser does not change size based on the amount of time charged
		        3) Laser does not destroy enemy ships
		        4) Laser does not destroy obstacles

	-Bugs fixed: 	1) Laser was not excluded from the list of objects that could kill player
		        2) The change in time was not properly calculated from when the charge began to when it ended
		        3) Missing functionality inside the laser script that took away health from an enemy
			4) Object needed a rigidbody

-Homing laser powerup: Play testing and debug logs were  used to verify that the homing missile’s movement was correct and that it would be destroyed after destroying an enemy.

	-Bugs found: 	1) Homing laser does not move if no enemies were present
			2) Homing Laser does not get destroyed after destroying an enemy

	-Bugs Fixed: 	1) Added a case where if there were no enemies present, fire across the screen in straight line motion.
			2) Incorrect order of execution of statements inside the homing laser movement script.
Misc:

Background scrolling: play tests and investigating game objects were used to ensure that the background image was scrolling and that the images were correctly displayed.

-Bugs found: 	1) Background was correctly scrolling across the screen (verified by
		   selecting appropriate game object) but the image was not displayed.

-Bugs fixed: 	1) A cube was used instead of a quad to house the image. This allowed 
		   for the material to be correctly rendered and visible in the scene 100% 
    		   of the time, previously it would seem that sometimes the image would 
   		   move and be visible.  


